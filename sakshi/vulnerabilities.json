[{"nonCompliant": "", "description": "A service was found to be shared with other apps on the device without an intent filter or a permission requirement therefore leaving it accessible to any other application on the device.", "relatedTo": "", "intro": "<p>\n    <span>Chin, et al., [<a href=\"https://www.securecoding.cert.org/confluence/display/java/AA.+References#AA.References-Chin11\">Chin 2011</a>] says:</span>\n    <span class=\"italics\">\n        &quot;If a Service is exported and not protected with strong permissions, then any application can start and bind to the Service. Depending on the duties of a particular Service, it may leak information or perform unauthorized tasks. Services sometimes maintain singleton application state, which could be corrupted.&quot;\n    </span>\n</p>\n\n<p>\n    To guard against such eventualities, an exported service should always be protected with strong permissions.\n</p>", "id": 1, "name": "Unprotected Services", "uuid": "294c5ce7-0952-52d7-895e-d416eb510896", "type": "vulnerabilities", "question": "Is Services in the Application Protected?", "successMessage": "It seems the services are protected", "compliant": "", "businessImplication": "Sensitive Data\u2019s can be shared through other services resulting in loss of crucial information.\n", "heading": "Protect exported services with strong permissions"}, {"nonCompliant": "<p>\n    MovatwiTouch, a Twitter client application, used a content provider to manage Twitter\u2019s consumer key, consumer secret, and access token. However, the content provider was made public, which enabled applications installed on users\u2019 devices to access this sensitive information.\n</p>\n\n<p>\n    The following entry in the AndroidManifest.xml does not have the android:exported attribute, which means, before API Level 16, the content provider is made public:\n</p>\n\n<h4>\n    AndroidManifest.xml\n</h4>\n\n<pre>\n&lt;provider android:name=&quot;.content.AccountProvider&quot;\nandroid:authorities=&quot;jp.co.vulnerable.accountprovider&quot; /&gt;\n</pre>", "description": "A content provider permission was set to allows access from any other app on the device. Content providers may contain sensitive information about an app and therefore should not be shared.", "relatedTo": "<ul>\n    <li>\n        <a href=\"https://jvn.jp/en/jp/JVN90289505/\">JVN#90289505</a> Content provider in MovatwiTouch fails to restrict access permissions\n    </li>\n</ul>\n", "intro": "<p>\n    The ContentProvider class provides a mechanism for managing and sharing data with other applications. When sharing a provider\u2019s data with other apps, access control should be carefully implemented to prohibit unauthorized access to sensitive data.\n</p>\n\n<p>\n    There are three ways to limit access to the content provider:\n</p>\n\n<ul>\n    <li>Public</li>\n    <li>Private</li>\n    <li>Restricted access</li>\n</ul>", "id": 2, "name": "Improper Content Provider Permissions", "uuid": "0d5db0c3-5405-52d7-89a6-702cba1bebb7", "type": "vulnerabilities", "question": "Does the Content Provider in the App Protected?", "successMessage": "Application seems to properly implement SSL or HTTPS is not implemented", "compliant": "<p>\n    The following entry in the AndroidManifest.xml file makes the content provider private so that other apps cannot access the data:\n</p>\n\n<pre>\n&lt;provider android:name=&quot;.content.AccountProvider&quot; android:exported=&quot;\nfalse&quot; android:authorities=&quot;jp.co.vulnerable.accountprovider&quot; /&gt;\n</pre>", "businessImplication": "If security controls are not properly implemented, content providers can lead to client side attacks like SQL injection. This works similarly to traditional SQL injection attacks.\n", "heading": "Limit the accessibility of an app's sensitive contentprovider"}, {"nonCompliant": "<p>\n    This noncompliant code example shows an app that has the android:debuggable attribute set to true being accessed to reveal sensitive data.\n</p>\n\n<pre>\n$ adb shell\nshell@android:/ $ run-as com.example.someapp sh\nshell@android:/data/data/com.example.someapp $ id\nuid=10060(app_60) gid=10060(app_60)\nshell@android:/data/data/com.example.someapp $ ls files/\nsecret_data.txt\nshell@android:/data/data/com.example.some $ cat files/secret_data.txt\npassword=GoogolPlex\naccount_number=31974286\n</pre>\n\n<p>\n    Clearly, with the android:debuggable attribute set to true, sensitive date related to the app can be revealed to any user.\n</p>", "description": "Debugging was enabled on the app which makes it easier for reverse engineers to hook a debugger to it. This allows dumping a stack trace and accessing debugging helper classes.", "relatedTo": "", "intro": "<p>\n    Android allows the attribute android:debuggable to be set to true so that the app can be debugged.  By default this attribute is disabled, i.e., it is set to false, but it may be set to true to help with debugging during development of the app.  However, an app should never be released with this attribute set to true as it enables users to gain access to details of the app that should be kept secure.  With the attribute set to true, users can debug the app even without access to its source code.\n</p>", "id": 3, "name": "Application Debug Enabled", "uuid": "fd49cccc-a654-5669-9dd3-b31c5521349a", "type": "vulnerabilities", "question": "Does the application has Debug Enabled?", "successMessage": "Debugging was disabled", "compliant": "<p>\n    Ensure that the android:debuggable attribute is set to false before the app is released:\n</p>\n\n<pre>\nandroid:debuggable=\"false\"\n</pre>\n\n<p>\n    Note that some development environments (including Eclipse/ADT and Ant) automatically set android:debuggable to true for incremental or debugging builds but set it tofalse for release builds.\n</p>", "businessImplication": "Applications can write sensitive data in debugging logs. Setting the logging level to FINE results in log messages being written for all of the data transmitted between the user's device and the server.\n", "heading": "Do not release apps that are debuggable"}, {"nonCompliant": "", "description": "A custom permission  controls whether or not other applications can access the affected apps features. The use of the dangerous label places no restrictions on which apps can access the application declaring the permission but the user will be warned that the dangerous permission is required during installation.", "relatedTo": "", "intro": "<p>\n    If an app is using a granted permission to respond to a calling app then it must check that the calling app as that permission as well. Otherwise, the responding app may be granting privileges to the calling app that it should not have.  (This is sometimes called the \"confused deputy\" problem.)\n</p>\n\n<p>\n    The methods Context.checkCallingPermission() and Context.enforceCallingPermission() can be used to ensure that the calling app has the correct permissions.\n</p>", "id": 4, "name": "Improper Custom Permission", "uuid": "b97bd063-0e4f-5dea-a85b-375946daa390", "type": "vulnerabilities", "question": "Protection level set in custom permission are safe?", "successMessage": "No custom Permission were found or the protection level seems to be sufficient", "compliant": "", "businessImplication": "", "heading": "Check that a calling app has appropriate permissions before responding"}, {"nonCompliant": "<p>The following code implements a custom MySSLSocketFactory class that inherits javax.net.ssl.SSLContext:</p>\n<pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> emptyTrustManager() <span style=' color: Blue;'>throws</span> IOException, KeyManagementException, NoSuchAlgorithmException {\n    TrustManager tm = <span style=' color: Blue;'>new</span> X509TrustManager() {\n\n        @Override\n        <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkClientTrusted(X509Certificate[] chain,\n                String authType) <span style=' color: Blue;'>throws</span> CertificateException {\n            <span style=' color: Green;'>// Do nothing -&gt; accept any certificates</span>\n        }\n\n        @Override\n        <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkServerTrusted(X509Certificate[] chain,\n                String authType) <span style=' color: Blue;'>throws</span> CertificateException {\n            <span style=' color: Green;'>// Do nothing -&gt; accept any certificates</span>\n        }\n\n        @Override\n        <span style=' color: Blue;'>public</span> X509Certificate[] getAcceptedIssuers() {\n            <span style=' color: Blue;'>return</span> <span style=' color: Blue;'>null</span>;\n        }\n    };\n}\n</pre>\n<p>\nIn the example above, checkClientTrusted()and checkServerTrusted() are overriden to make a blank implementation so that SSLSocketFactory does not verify the SSL certificate. The MySSLSocketFactory class is used to create an instance of HttpClient in another part of the application.\n</p>\n", "description": "Implements naive certificate check. This TrustManager breaks certificate validation.", "relatedTo": "<ul>\n    <li><a href=\"http://jvn.jp/en/jp/JVN39218538/\">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN75084836/\">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN68156832/\">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li>\n</ul>", "intro": "<p>Android apps that use SSL/TLS protocols for secure communication should properly verify server certificates. The basic verification includes:\n</p>\n\n<ul>\n    <li>verify that the subject (CN) of X.509 certificate and the URL matches</li>\n    <li>verify that the certificate is signed by the trusted CA</li>\n    <li>verify that the signature is correct</li>\n    <li>verify that the certificate is not expired</li>\n</ul>\n\n<p>\n    A developer has the freedom to customize their SSL implementation. The developer should properly use SSL as appropriate to the intent of the app and the environment the apps are used in. If the SSL is not correctly used, a user's sensitive data may leak via the vulnerable SSL communication channel.\n</p>\n\n<p>Fahl et al [<a href=\"https://www.securecoding.cert.org/confluence/display/java/AA.+References#AA.References-Fahl2012\">Fahl 2012</a>] describes the following patterns of the insecure use of SSL:</p>\n\n<ul>\n    <li><b>Trusting All Certificates</b>: The developer implements the TrustManager interface so that it will trust all the server\n        certificate (regardless of who signed it, what is the CN etc.)\n    </li>\n    <li><b>Mixed-Mode/No SSL</b>: A developer mixes secure and insecure connections in the same app or does not use SSL at all.</li>\n</ul>\n\n<p>On Android, using HttpURLConnection is recommended for HTTP client implementation.</p>\n", "id": 5, "name": "Broken Trust Manager for SSL", "uuid": "3c49b28e-12ca-5b38-a97e-3d25e3986fae", "type": "vulnerabilities", "question": "Is the Trust Manager for SSL not implemented properly?", "successMessage": "Trust Manager for SSL Seems to be perfect, or SSL were not implemented and used in your application.", "compliant": "<p>\n    The compliant solution is given below which shows how to solve the issue with the non compliant code:\n</p>\n<pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkCertTrusted(X509Certificate[] chain, String authType, <span style=' color: Blue;'>boolean</span> isServer)\n    <span style=' color: Blue;'>throws</span> CertificateException\n{\n    <span style=' color: Blue;'>try</span> {\n        <span style=' color: Blue;'>if</span> (isServer)\n            appTrustManager.checkServerTrusted(chain, authType);\n        <span style=' color: Blue;'>else</span>\n            appTrustManager.checkClientTrusted(chain, authType);\n    } <span style=' color: Blue;'>catch</span> (CertificateException ae) {\n        <span style=' color: Green;'>// if the cert is stored in our appTrustManager, we ignore expiredness</span>\n        <span style=' color: Blue;'>if</span> (isExpiredException(ae)) {\n            Log.i(<span style=' color: Maroon;'>\"log\"</span>, <span style=' color: Maroon;'>\"accepting expired certificate from keystore\"</span>);\n            <span style=' color: Blue;'>return</span>;\n        }\n        <span style=' color: Blue;'>if</span> (isCertKnown(chain[<span style=' color: Maroon;'>0</span>])) {\n            Log.i(<span style=' color: Maroon;'>\"log\"</span>, <span style=' color: Maroon;'>\"accepting cert already stored in keystore\"</span>);\n            <span style=' color: Blue;'>return</span>;\n        }\n        <span style=' color: Blue;'>try</span> {\n            <span style=' color: Blue;'>if</span> (defaultTrustManager == <span style=' color: Blue;'>null</span>)\n                <span style=' color: Blue;'>throw</span> ae;\n            Log.d(<span style=' color: Maroon;'>\"log\"</span>, <span style=' color: Maroon;'>\"trying defaultTrustManager\"</span>);\n            <span style=' color: Blue;'>if</span> (isServer)\n                defaultTrustManager.checkServerTrusted(chain, authType);\n            <span style=' color: Blue;'>else</span>\n                defaultTrustManager.checkClientTrusted(chain, authType);\n        } <span style=' color: Blue;'>catch</span> (CertificateException e) {\n            Log.d(<span style=' color: Maroon;'>\"log\"</span>, <span style=' color: Maroon;'>\"defaultTrustManager failed: \"</span> + e);\n            interactCert(chain, authType, e);\n        }\n    }\n}\n\n<span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkTrustManager() <span style=' color: Blue;'>throws</span> IOException, KeyManagementException, NoSuchAlgorithmException {\n    TrustManager tm = <span style=' color: Blue;'>new</span> X509TrustManager() {\n\n        @Override\n        <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkClientTrusted(X509Certificate[] chain,\n                String authType) <span style=' color: Blue;'>throws</span> CertificateException {\n            checkCertTrusted(chain, authType, <span style=' color: Maroon;'>false</span>);\n        }\n\n        @Override\n        <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkServerTrusted(X509Certificate[] chain,\n                String authType) <span style=' color: Blue;'>throws</span> CertificateException {\n            checkCertTrusted(chain, authType, <span style=' color: Maroon;'>false</span>);\n        }\n\n        @Override\n        <span style=' color: Blue;'>public</span> X509Certificate[] getAcceptedIssuers() {\n            <span style=' color: Blue;'>return</span> defaultTrustManager.getAcceptedIssuers();\n        }\n    };\n}</pre>\n<p>\n    The method checkCertTrusted() gives an idea about how to solve this issue. If a custom keystore is being used to load certificates then we need to define and do a failsafe load of those certificates. </p>\n", "businessImplication": "In the event that a user (anonymous or verified) is able to execute over-privileged functionality, the business may experience the following impacts:\n\n<ul>\n    <li>Reputational Damage</li>\n    <li>Fraud</li>\n    <li>Information Theft</li>\n</ul>\n", "heading": "Trust Manager for SSL/TLS is not properly configured"}, {"nonCompliant": "<p>The following code inherits javax.net.ssl.SSLContext:</p>\n<pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> HostnameVerifier() {\n    HostnameVerifier hv = <span style=' color: Blue;'>new</span> HostnameVerifier() {\n        @Override\n        <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>boolean</span> verify(String hostname, SSLSession session) {\n            <span style=' color: Green;'>// Always return true -&gt; Accespt any host names</span>\n            <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>true</span>;\n        }\n    };\n}</pre>\n<p>The hostname verifier instead of verifying the hostname always returns true without checking the contents</p>\n", "description": "Implements naive hostname verification. This HostnameVerifier breaks certificate validation!", "relatedTo": "<ul>\n    <li><a href=\"http://jvn.jp/en/jp/JVN39218538/\">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN75084836/\">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN68156832/\">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li>\n</ul>", "intro": "<p>Allowing All Hostnames: The app does not verify if the certificate is issued for the URL the client is connecting to.\nFor example, when a client connects to example.com, it will accept a server certificate issued for some-other-domain.com.</p>\n<p>On Android, using HttpURLConnection is recommended for HTTP client implementation.</p>\n", "id": 6, "name": "Broken hostnameverifier for SSL", "uuid": "9fd60981-c7ff-52c9-b75f-7774c8133ad2", "type": "vulnerabilities", "question": "Is the Hostnameverifier for SSL not implemented properly?", "successMessage": "HostNameVerifier for SSL Seems to be verfying hostnames properly, or SSL were not implemented in your application.", "compliant": "<p> The code example shows how to verify hostname using a wrapHostnameVerifier which also checks for custom loaded certificates\n</p>\n<pre><span style=' color: Blue;'>public</span> HostnameVerifier wrapHostnameVerifier(<span style=' color: Blue;'>final</span> HostnameVerifier defaultVerifier) {\n    <span style=' color: Blue;'>if</span> (defaultVerifier == <span style=' color: Blue;'>null</span>)\n        <span style=' color: Blue;'>throw</span> <span style=' color: Blue;'>new</span> IllegalArgumentException(<span style=' color: Maroon;'>\"The default verifier may not be null\"</span>);\n\n    <span style=' color: Blue;'>return</span> <span style=' color: Blue;'>new</span> SecuringHostnameVerifier(defaultVerifier);\n}\n\n\n\n<span style=' color: Blue;'>class</span> SecuringHostnameVerifier <span style=' color: Blue;'>implements</span> HostnameVerifier {\n    <span style=' color: Blue;'>private</span> HostnameVerifier defaultVerifier;\n\n    <span style=' color: Blue;'>public</span> MemorizingHostnameVerifier(HostnameVerifier wrapped) {\n        defaultVerifier = wrapped;\n    }\n\n    @Override\n    <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>boolean</span> verify(String hostname, SSLSession session) {\n        Log.d(<span style=' color: Maroon;'>\"log\"</span>, <span style=' color: Maroon;'>\"hostname verifier for \"</span> + hostname + <span style=' color: Maroon;'>\", trying default verifier first\"</span>);\n        <span style=' color: Green;'>// if the default verifier accepts the hostname, we are done</span>\n        <span style=' color: Blue;'>if</span> (defaultVerifier.verify(hostname, session)) {\n            Log.d(<span style=' color: Maroon;'>\"log\"</span>, <span style=' color: Maroon;'>\"default verifier accepted \"</span> + hostname);\n            <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>true</span>;\n        }\n        <span style=' color: Green;'>// otherwise, we check if the hostname is an alias for this cert in our keystore</span>\n        <span style=' color: Blue;'>try</span> {\n            X509Certificate cert = (X509Certificate)session.getPeerCertificates()[<span style=' color: Maroon;'>0</span>];\n            <span style=' color: Blue;'>if</span> (cert.equals(appKeyStore.getCertificate(hostname.toLowerCase(Locale.US)))) {\n                Log.d(<span style=' color: Maroon;'>\"log\"</span>, <span style=' color: Maroon;'>\"certificate for \"</span> + hostname + <span style=' color: Maroon;'>\" is in keystore. accepting.\"</span>);\n                <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>true</span>;\n            } <span style=' color: Blue;'>else</span> {\n                Log.d(<span style=' color: Maroon;'>\"log\"</span>, <span style=' color: Maroon;'>\"server \"</span> + hostname + <span style=' color: Maroon;'>\" provided wrong certificate.\"</span>);\n                <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>false</span>;\n            }\n        } <span style=' color: Blue;'>catch</span> (Exception e) {\n            e.printStackTrace();\n            <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>false</span>;\n        }\n    }\n}</pre>\n", "businessImplication": "In the event that a user (anonymous or verified) is able to execute over-privileged functionality, the business may experience the following impacts:\n <ul>\n     <li>Reputational Damage</li>\n     <li>Fraud</li>\n     <li>Information Theft</li>\n </ul>\n", "heading": "Hostname Verifier for SSL/TLS is not properly configured"}, {"nonCompliant": "<p>The following code implements a custom MySSLSocketFactory class that inherits javax.net.ssl.SSLContext:</p>\n<pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>class</span> InsecureSocketFactory <span style=' color: Blue;'>extends</span> SSLSocketFactory {\n    <span style=' color: Blue;'>protected</span> SSLSocketFactory _factory;\n    <span style=' color: Blue;'>public</span> InsecureSocketFactory() {\n        <span style=' color: Blue;'>try</span> {\n            SSLContext ctx = SSLContext.getInstance(<span style=' color: Maroon;'>\"SSL\"</span>);\n            ctx.init(<span style=' color: Blue;'>null</span>, <span style=' color: Blue;'>new</span> TrustManager[] { <span style=' color: Blue;'>new</span> InsecureTrustManager() }, <span style=' color: Blue;'>null</span>);\n            _factory = ctx.getSocketFactory();\n        } <span style=' color: Blue;'>catch</span> (Exception e) {\n            <span style=' color: Blue;'>throw</span> <span style=' color: Blue;'>new</span> RuntimeException(e);\n        }\n    }\n}\n</pre>\n<p>\n    In the example above, the InsecureSocketFactory accepts all certificates silently, which even bypasses the check for trustmanagers\n</p>\n", "description": "SSL Implementations are not proper in this application", "relatedTo": "<ul>\n    <li><a href=\"http://jvn.jp/en/jp/JVN39218538/\">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN75084836/\">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN68156832/\">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li>\n</ul>", "intro": "<p>\n    Android SDK 4.0 and later offers packages to implement capabilities to establish network connections. For example, by using java.net, javax.net, android.net ororg.apache.http, a developer can create server sockets or HTTP connection. org.webkit offers functions necessary to implement web browsing capabilities.\n</p>\n\n<p>\n    A developer has the freedom to customize their SSL implementation. The developer should properly use SSL as appropriate to the intent of the app and the environment the apps are used in. If the SSL is not correctly used, a user's sensitive data may leak via the vulnerable SSL communication channel.\n</p>\n\n<p>On Android, using HttpURLConnection is recommended for HTTP client implementation.</p>\n", "id": 7, "name": "Insecure SSLSocketFactory Implemented", "uuid": "0fa19202-2a36-5305-a3a7-07bc4e6db8aa", "type": "vulnerabilities", "question": "Does this application has probable SSL Error in implementation?", "successMessage": "No SSL Errors were found", "compliant": "<p>\n    The compliant solution may vary, depending on the actual implementation. For examples of secure implementation such as using a self-signed server certificate, please refer to \"<a href=\"http://www.jssec.org/dl/android_securecoding.pdf\">Android Application Secure Design/Secure Coding Guidebook</a>\", Section 5.4 Communicate by HTTPS.\n</p>\n", "businessImplication": "", "heading": "SSL SocketFactory is not implemeted properly"}, {"nonCompliant": "<p>The following code extends HttpClient class that inherits javax.net.ssl.SSLContext:</p>\n<pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> allowAllHostnameVerifier() {\n    SSLSocketFactory sf = <span style=' color: Blue;'>null</span>;\n\n    sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n}</pre>\n<p>\n    This will enable the use of <b>SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER</b> as a result, host name verification that should take place when establishing an SSL connection is disabled and will lead to the same situation as all the certificate is trusted.\n</p>\n", "description": "Implements AllowAllHostname Verifier which might allow hacker to eavesdrop into the connection.", "relatedTo": "<ul>\n    <li><a href=\"http://jvn.jp/en/jp/JVN39218538/\">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN75084836/\">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN68156832/\">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li>\n</ul>", "intro": "<p>Android apps that use SSL/TLS protocols for secure communication should properly verify server certificates which should verify that the subject (CN) of X.509 certificate and the URL matches\n</p>\n\n<p><b>Allowing All Hostnames</b>: The app does not verify if the certificate is issued for the URL the client is connecting to. For example, when a client connects to example.com, it will accept a server certificate issued for some-other-domain.com.</p>\n\n<p>On Android, using HttpURLConnection is recommended for HTTP client implementation.</p>\n", "id": 8, "name": "Hostname Verifier Allows all hostname", "uuid": "e5011adc-7c60-5437-97d4-867e7b6a0971", "type": "vulnerabilities", "question": "Does this application has AllowAllHostname Verification?", "successMessage": "AllowAllHostname verifier seems to be disabled.", "compliant": "<p>\n    Never use <b>SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER</b> in production code\n<p>\n    Please refer to \"<a href=\"http://www.jssec.org/dl/android_securecoding.pdf\">Android Application Secure Design/Secure Coding Guidebook</a>\", Section 5.4 Communicate by HTTPS.\n</p>\n", "businessImplication": "In the event that a user (anonymous or verified) is able to execute over-privileged functionality, the business may experience the following impacts:\n<ul>\n    <li>Reputational Damage</li>\n    <li>Fraud</li>\n    <li>Information Theft</li>\n</ul>\n", "heading": "Properly Verify Server Certificate on SSL/TLS"}, {"nonCompliant": "<p>The following code shows how onReceivedSslError was used to bypass the check in WebViewClient:</p>\n\n<pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>class</span> SSLAcceptingWebViewClient <span style=' color: Blue;'>extends</span> CordovaWebViewClient {\n    <span style=' color: Blue;'>public</span> SSLAcceptingWebViewClient(DroidGap ctx) {\n        <span style=' color: Blue;'>super</span>(ctx);\n    }\n    @Override\n    <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {\n        <span style=' color: Green;'>//proceed or pass</span>\n        handler.proceed(); <span style=' color: Green;'>// Ignore SSL certificate errors</span>\n    }\n\n}\n</pre>\n", "description": "The default handling of WebViewClient should handle the onreceivedsslerror properly, which might break certificate validation", "relatedTo": "<ul>\n    <li><a href=\"http://jvn.jp/en/jp/JVN39218538/\">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN75084836/\">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>\n    <li><a href=\"http://jvn.jp/en/jp/JVN68156832/\">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li>\n</ul>", "intro": "<p>WebViews can introduce a number of security concerns and should be implemented carefully. In particular, many vulnerabilities have been discovered that exploit the use of the addJavscriptInterface API and bypassing onReceivedSslError check\n</p>\n<p>\nWebView does support SSL/TLS, however, the blank screen is an indication that the WebView does not believe that the certificate is valid. This may happen with a certificate that is self-signed or a from a root auth that is not set up in android. However if that check is bypassed, then it removes all security from SSL.\n</p>\n", "id": 9, "name": "App extends WebViewClient", "uuid": "f49241a4-fd64-5e84-b991-62514d44c01a", "type": "vulnerabilities", "question": "Is this application using WebViewClient correctly handling the onreceivedsslerror method?", "successMessage": "Application seems to be handling WebViewClient correctly or the Application has no implemetation of WebViewClient", "compliant": "<p>\n    This can be fixed by using the onReceivedSslError to stop or notify the user and the application.\n</p>\n<pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)  {\n    <span style=' color: Green;'>//STOP OR ALERT THE USER</span>\n}</pre>\n", "businessImplication": "", "heading": "Webview Client doesn't handles secured connection properly"}, {"nonCompliant": "", "description": "Application seems to be using extra permissions which are not really needed", "relatedTo": "", "intro": "<p>\n    An app might request a user for certain permissions, like access to SD card, contacts, social profiles, etc. which has not actually been invoked while the scan was running. We list out all these permissions so that you can optimize your app and follow proper compliance checks.\n</p>\n", "id": 10, "name": "Unused Permissions", "uuid": "9bd166be-30dc-5f09-9c06-422edaedef0c", "type": "vulnerabilities", "question": "Is your Application having over-privileged permission?", "successMessage": "Application seems to have exact set of permissions required", "compliant": "<p>\n    Do not request for permissions beyond what your app actually needs\n</p>\n", "businessImplication": "<p>\n    Users might not download your app when presented with a long list of permissions. Imagine a flashlight app requesting access to SD card, camera, contacts, SMS and more. This is an invitation to poor ratings and reviews on App Stores. This also breaks necessary compliances.\n</p>\n", "heading": "Do not ask for permissions that may not be used"}, {"nonCompliant": "<p>\n    This noncompliant code example shows an application that calls the addJavascriptInterface() method, and hence is not secure for API level JELLY_BEAN and lower.\n</p>\n\n<pre>WebView webView = <span style=' color: Blue;'>new</span> WebView(<span style=' color: Blue;'>this</span>);\nsetContentView(webView);...\n<span style=' color: Blue;'>class</span> JsObject {\n<span style=' color: Blue;'>private</span> String sensitiveInformation;\n\n...\n<span style=' color: Blue;'>public</span> String toString() {\n    <span style=' color: Blue;'>return</span> sensitiveInformation;\n}\n\n}\nwebView.addJavascriptInterface(<span style=' color: Blue;'>new</span> JsObject(), <span style=' color: Maroon;'>\"injectedObject\"</span>);\nwebView.loadData(<span style=' color: Maroon;'>\"\"</span>, <span style=' color: Maroon;'>\"text/html\"</span>, <span style=' color: Blue;'>null</span>);\nwebView.loadUrl(<span style=' color: Maroon;'>\"http://www.example.com\"</span>);\n</pre>\n\n<p>\n    JavaScript can now control the host. Java reflection could be used to access any of the public methods of an injected object, using the permissions of the app.\n</p>\n", "description": "Application seems to use JavascriptInterface, using that, an attacker can do a Remote Code Execution on your application and steal sensitive informations.", "relatedTo": "", "intro": "<p>\n    For API level JELLY_BEAN or below, allowing an app to use the addJavascriptInterface method with untrusted content in a WebView leaves the app vulnerable to scripting attacks using reflection to access public methods from JavaScript.  Untrusted content examples include content from any HTTP URL (as opposed to HTTPS) and user-provided content. The method addJavascriptInterface(Object, String) is called from the android.webkit.WebView class. Sensitive data and app control should not be exposed to scripting attacks.\n</p>", "id": 11, "name": "Remote Code Execution Through JavascriptInterface", "uuid": "07138db2-43ad-5682-986e-766b1aca15d3", "type": "vulnerabilities", "question": "Is your Application using JavascriptInterface? Is the Application over non-SSL or broken SSL Implementation?", "successMessage": "Application is safe from Remote Code execution through JavascriptInterface", "compliant": "<ol>\n<li>\n\n    <p>\n        Compliant code could refrain from calling the addJavascriptInterface() method.\n    </p>\n\n    <pre>\nWebView webView = new WebView(this);\nsetContentView(webView);\n    </pre>\n</li>\n<li>\n\n    <p>\n        Another compliant solution is to specify in the app's manifest that the app is only for API levels JELLY_BEAN_MR1 and above. For these API levels, only public methods that are annotated with JavascriptInterface can be accessed from JavaScript. API level 17 is JELLY_BEAN_MR1.\n    </p>\n\n    <pre>\n&lt;manifest&gt;\n&lt;uses-sdk android:minSdkVersion=&quot;17&quot; /&gt;\n...\n \n&lt;/manifest&gt;\n    </pre>\n</li>\n</ol>", "businessImplication": "", "heading": "Do not provide addJavascriptInterface method access in a WebView which could contain untrusted content. (API level JELLY_BEAN or below)"}, {"nonCompliant": "<p>\n    This noncompliant code example shows an AndroidManifest.xml file for an application that exports the activity to other apps, but does not restrict access to its sensitive activity:\n</p>\n\n<pre>\n&lt;activity android:configChanges=&quot;keyboard|keyboardHidden|orientation&quot; android:name=&quot;.media.yfrog.YfrogUploadDialog&quot; android:theme=&quot;@style/Vulnerable.Dialog&quot; android:windowSoftInputMode=&quot;stateAlwaysHidden&quot;&gt;           \n&lt;intent-filter android:icon=&quot;@drawable/yfrog_icon&quot; android:label=&quot;@string/YFROG&quot;&gt;\n    &lt;action android:name=&quot;jp.co.vulnerable.ACTION_UPLOAD&quot; /&gt;                \n    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;                \n    &lt;data android:mimeType=&quot;image/*&quot; /&gt;                \n    &lt;data android:mimeType=&quot;video/*&quot; /&gt;            \n&lt;/intent-filter&gt;        \n&lt;/activity&gt;\n</pre>\n\n<p>\n    android:name refers to the name of the class that implements this activity. The name of the package is \"jp.co.vulnerable\" so the fully qualified name of the class implementing this activity is jp.co.vulnerable.media.yfrog.YfrogUploadDialog. Since the intent filter is defined, this activity is exported to other apps.\n</p>", "description": "An activity was found to be shared with other apps on the device without an intent filter or a permission requirement therefore leaving it accessible to any other application on the device.", "relatedTo": "<ul>\n    <li><a href=\"https://jvn.jp/en/jp/JVN31860555/\">JVN#31860555</a>  Twicca fails to restrict access permissions  </li>\n</ul>", "intro": "<p>\n    On Android, declaring an intent filter for an activity in the AndroidManifest.xml file means that the activity may be exported to other apps. If the activity is intended solely for the internal use of the app and an intent filter is declared then any other apps, including malware, can activate the activity for unintended use.\n</p>\n\n<p>\n    In the case of the vulnerability in the Twicca app (in versions 0.7.0 through 0.9.30, see the link below), by launching Twicca's activity, another app that does not have permission to access the SD card or network could upload images or movies stored on the SD card to a social networking service with the Twicca user's Twitter account.\n</p>", "id": 12, "name": "Unprotected Activities", "uuid": "c1a0f2d2-d047-5315-84c4-db5b49bd22c5", "type": "vulnerabilities", "question": "Is Activity in the Application Protected?", "successMessage": "Activities seems to be protected", "compliant": "<ol>\n<li>\n\n    <p>\n        In this compliant solution the activity is not exported:\n    </p>\n\n    <pre>\n&lt;activity android:configChanges=&quot;keyboard|keyboardHidden|orientation&quot; android:name=&quot;.media.yfrog.YfrogUploadDialog&quot; android:theme=&quot;@style/ VulnerableTheme.Dialog&quot; android:windowSoftInputMode=&quot;stateAlwaysHidden&quot; android:exported=&quot;false&quot;&gt; \n&lt;/activity&gt;\n    </pre>\n\n    <p>\n        By declaring android:exported=\"false\" for an activity tag in the AndroidManifest.xml file, the activity is restricted to only accept intents from within the same app or from an app with the same user ID.\n    </p>\n</li>\n<li>\n\n    <p>\n        This vulnerability was fixed in Twicca v0.9.31. Instead of declaring the activity exported=\"false\" in AndroidManifest.xml, Twicca fixed this vulnerability by validating the caller of this activity. In the onCreate() method of the activity class, code was added to check if the package name of the caller is the same as the package name of itself. If the package names are different, the activity exits:\n    </p>\n\n    <pre>\npublic void onCreate(Bundle arg5) {\n    super.onCreate(arg5);...\n    ComponentName v0 = this.getCallingActivity();\n    if (v0 == null) {\n        this.finish();\n    } else if (!jp.r246.twicca.equals(v0.getPackageName())) {\n        this.finish();\n    } else {\n        this.a = this.getIntent().getData();\n        if (this.a == null) {\n            this.finish();\n        }...\n    }\n}\n}\n    </pre>\n\n    <p>\n        An Android developer can arbitrarily choose a package name, so different app developers could choose the same package name. Therefore, it is generally not recommended to use the package name for validating the caller of the activity. The recommended alternative is to check the developer's certificate, instead of the package name.\n    </p>\n\n    <p>\n        However, considering the following facts, Twicca's solution may be logical and safe against the exploit:\n    </p>\n\n    <ul>\n        <li>Only one app with a particular package name can exist on Google Play.   </li>\n        <li>If a user tries to install an app whose package name already exists on the device, the installation either will fail or will overwrite the previously installed app.</li>\n    </ul>\n</li>\n</ol>", "businessImplication": "", "heading": "Restrict access to sensitive activities"}, {"nonCompliant": "<p>\n    This noncompliant code example shows JDBC code that is vulnerable to SQL injection. The SQL statement sql accepts unsanitized input arguments.\n</p>\n\n<pre><span style=' color: Blue;'>class</span> Login {\n\n<span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> doPrivilegedAction(String username, String password) <span style=' color: Blue;'>throws</span> SQLException {\n\n    DriverManager.registerDriver(<span style=' color: Blue;'>new</span> com.microsoft.jdbc.sqlserver.SQLServerDriver());\n    Connection connection = DriverManager.getConnection(\n        <span style=' color: Maroon;'>\"jdbc:microsoft:sqlserver://&lt;HOST&gt;:1433\"</span>, <span style=' color: Maroon;'>\"&lt;UID&gt;\"</span>, <span style=' color: Maroon;'>\"&lt;PWD&gt;\"</span>);\n\n    <span style=' color: Blue;'>if</span> (connection != <span style=' color: Blue;'>null</span>) {\n        String sql = <span style=' color: Maroon;'>\"select * from db_user where username = '\"</span> + username +\n            <span style=' color: Maroon;'>\"' and password = '\"</span> + password + <span style=' color: Maroon;'>\"'\"</span>;\n\n        Statement stmt = connection.createStatement();\n        ResultSet rs = stmt.executeQuery(sql);\n        <span style=' color: Blue;'>if</span> (!rs.next()) {\n            <span style=' color: Blue;'>throw</span> <span style=' color: Blue;'>new</span> SecurityException(<span style=' color: Maroon;'>\"User name or Password incorrect\"</span>);\n        }\n        <span style=' color: Green;'>// Authenticated; proceed</span>\n    }\n}\n\n</pre>\n\n<p>\n    If the attacker enters a valid user name securecoding and enters 'OR username = 'securecoding for the password argument, the SQL statement evaluates to select * from db_user where username = '' OR username = 'securecoding' and password='', consequently bypassing the login password check. Similarly, an input ofsomeuser' OR '1' = '1 would bypass both the user name and password checks, granting the attacker unrestricted access.\n</p>\n", "description": "Data retrieved from a mobile app's server contains malformed data that results in a SQL injetion within the mobile device's local databases. Local SQL injections may result in local malware injection, information theft, and much more", "relatedTo": "", "intro": "<p>\n    An SQL injection vulnerability arises when the original SQL query can be altered to form an altogether different query. Execution of this altered query may result in information leaks or data modification. The primary means of preventing SQL injection are validating and sanitizing user input, and parameterizing the query.\n</p>", "id": 13, "name": "SQL Injection", "uuid": "05b15026-0546-5d3d-8283-2629331942e3", "type": "vulnerabilities", "question": "Am I Vulnerable To SQL Injection through WEB API?", "successMessage": "Application is not vulnerable to SQL Injection through Web API", "compliant": "<p>\n    Input validation is a prerequisite for proper query construction. This compliant solution validates the length of the username and password arguments. It also uses ajava.sql.PreparedStatement instead of java.sql.Statement.\n</p>\n\n<pre>\nclass Login {\npublic void doPrivilegedAction(String username, String password) throws SQLException {\n\n    // Ensure that the length of username and password is legitimate \n    if ((username.length() >= 8) || (password.length() >= 20)) {\n        // Handle error\n    }\n\n    DriverManager.registerDriver(new com.microsoft.jdbc.sqlserver.SQLServerDriver());\n    Connection connection = DriverManager.getConnection(\n        \"jdbc:microsoft:sqlserver://<HOST>:1433\", \"<UID>\", \"<PWD>\");\n    if (connection != null) {\n        String sql = \"select * from db_user where username=? and password=?\";\n\n        //Use PreparedStatement for type enforcement\n        PreparedStatement stmt = connection.prepareStatement(sql);\n        stmt.setString(1, username);\n        stmt.setString(2, password);\n        ResultSet rs = stmt.executeQuery();\n\n        if (!rs.next()) {\n            throw new SecurityException(\"User name or Password incorrect\");\n        }\n        // Authenticated; proceed\n    }\n}\n}\n</pre>", "businessImplication": "", "heading": "Prevent SQL Injection"}, {"nonCompliant": "<p>This noncompliant code example shows an application that creates a file that is world readable, and hence not secure.</p>\n\n<pre>openFileOutput(<span style=' color: Maroon;'>\"someFile\"</span>, MODE_WORLD_READABLE);</pre>\n\n<p>Any application could read the file and access any data stored in it.</p>\n", "description": "Insecured informations were found in shared preference. One shouldn't use un-encrypted information in SharedPreference.", "relatedTo": "", "intro": "<p>\n    In Android apps, data can be communicated via intents, or data can be written to files, distributed using shared ferences, or stored in databases. In all these cases, if the data is sensitive, it is important to keep the data secure. That is, it should not be possible for other apps (or, more strictly, apps with different userids) to be able to access this data, or for the data to be accessible to other programs or people, if the data owner does not intend that.\n</p>\n\n<p>\n    Data security (for non-intent communication channels) can be supported by creating the file, shared preference or database with MODE_PRIVATE on internal storage or with MODE_PRIVATE and encrypted (using secure encryption techniques, and using an encryption key only secure parties/apps have) on external storage. MODE_PRIVATE is a constant defined by the class android.content.Context. It may be used as the mode parameter in the methods openFileOutput(), getSharedPreferences(),\n    andopenOrCreateDatabase() (which are all also defined in the class android.content.Context).\n</p>\n\n<p>\n    Static taint flow analysis can be done for a set of apps, to trace data from each source (an input of data which cannot be fully predicted by static analysis, e.g., text input by a user) to reachable sinks (data output to a location that other applications or methods can access, e.g., sending the data over a bluetooth connection). Taint flow analysis helps users understand many possible source to sink flows, including flows that include intents and/or static fields.\n</p>", "id": 14, "name": "Information in Shared Preference", "uuid": "22b55249-c678-527d-a291-8b8656f30ef3", "type": "vulnerabilities", "question": "Is any sensitive information is leaking through SharedPreference?", "successMessage": "No lekage of data were found in SharedPreference", "compliant": "<p>\n    In this compliant solution the file is created using MODE_PRIVATE, so it cannot be accessed other than\nby apps with the same userid as the app that created the file.\n</p>\n\n<pre>\nopenFileOutput(\"someFile\", MODE_PRIVATE);\n</pre>", "businessImplication": "Typically, malicious code steals sensitive information (passwords, session cookies, personally identifiable information, etc). Hence, the associated business impacts include:\n<ul>\n    <li>Fraud</li>\n    <li>Privacy Violations</li>\n</ul>\n", "heading": "Ensure That Sensitive Data is Kept Secure"}, {"nonCompliant": "<p> Using HTTP with SSL or TLS to connect to internet, or without a proper certificate the connection can be easily eavesdropped by attacker without the knowledge of the user. </p>\n\n<pre>String link = <span style=' color: Maroon;'>\"http://www.google.com\"</span>;\nURL url = <span style=' color: Blue;'>new</span> URL(link);\n\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();\nconn.connect();\n\nInputStream is = conn.getInputStream();\nBufferedReader reader =<span style=' color: Blue;'>new</span> BufferedReader(<span style=' color: Blue;'>new</span> InputStreamReader(is, <span style=' color: Maroon;'>\"UTF-8\"</span>));\nString webPage = <span style=' color: Maroon;'>\"\"</span>,data=<span style=' color: Maroon;'>\"\"</span>;\nwhile ((data = reader.readLine()) != <span style=' color: Blue;'>null</span>){\n   webPage += data + <span style=' color: Maroon;'>\"\\n\"</span>;\n}</pre>\n\n<p> One can do a MITM attack and the use wouldn't even know that someone is eavesdropping it. </p>\n", "description": "Insufficient transport layer protection issues happen when the data is sent from the mobile app to the server over unsecure channels. Whether the data is transmitted through the carrier network or through WiFi, it will end up through the Internet either way before it could reach the remote server. There are several ways where unprotected data transmitted over the network could be sniffed; things like routers, proxies, cell towers, are some of the few ways data could be sniffed while in transit.", "relatedTo": "", "intro": "<p>\n    Insufficient transport layer protection issues happen when the data is sent from the mobile app to the server over unsecure channels. Whether the data is transmitted through the carrier network or through WiFi, it will end up through the Internet either way before it could reach the remote server. There are several ways where unprotected data transmitted over the network could be sniffed; things like routers, proxies, cell towers, are some of the few ways data could be sniffed while in transit.\n</p>", "id": 15, "name": "Insufficient Transport Layer Protection", "uuid": "d7db7f29-b8d5-5c47-9b44-bea3d0c60a15", "type": "vulnerabilities", "question": "Is your Application using proper Transport Layer protection? Is HTTPS enabled in your application?", "successMessage": "Application seems to have SSL enabled and sufficient protection is being used to prevent Information lekage.", "compliant": "<p>\n    Never use HTTP url to download data. create a valid HTTPS request through which only sensitive data can be downloaded.\n</p>\n", "businessImplication": "The violation of a user's confidentiality may result in:\n<ul>\n    <li>Identity theft</li>\n    <li>Fraud</li>\n    <li>Reputational Damage</li>\n</ul>\n", "heading": "Insufficient Transport Layer Protection"}, {"nonCompliant": "", "description": "Traces of Crypto Keys which might be intermediate keys used when loading the different libraries.", "relatedTo": "", "intro": "<p>\n    The predominant Android cryptographic security provider API defaults to using an insecure AES encryption method: ECB block cipher mode for AES encryption. Android's default cryptographic security provider (since version 2.1) is BouncyCastle. \n</p>\n\n<p>\n    NOTE: Java also chose ECB as a default value when only the AES encryption method is chosen. So, this rule also applies to Java, but for Java's different default cryptographic security provider. Oracle Java's default cryptographic security provider is SunJCE.\n</p>\n\n<p>\n    Default behaviors of cryptographic libraries used in Android systems often do not use recommended practices. For example, the predominant Android Java security provider API defaults to using an insecure AES encryption method: ECB block cipher mode for AES encryption. Extensive app testing by [Egele 2013] has shown that the following 6 rules are often not followed, resulting in 88% of apps with cryptographic APIs on Google Play making at least one mistake. \n</p>\n\n<p>\n    Six common cryptography rules they tested:\n</p>\n\n<ol>\n    <li>Do not use ECB mode for encryption.</li>\n    <li>Do not use a non-random IV for CBC encryption.</li>\n    <li>Do not use constant encryption keys.</li>\n    <li>Do not use constant salts for PBE.</li>\n    <li>Do not use fewer than 1,000 iterations for PBE.</li>\n    <li>Do not use static seeds to seed SecureRandom(\u00b7).</li>\n</ol>", "id": 16, "name": "Derived Crypto Keys", "uuid": "196c3ba5-e16c-52ef-9587-fd61db601b08", "type": "vulnerabilities", "question": "Is your Application using insecure AES encryption method?", "successMessage": "Application seems to be using the correct cryptographic encryption method or is not using it at all", "compliant": "", "businessImplication": "Broken cryptography will result in the following:\n<ul>\n    <li>Privacy Violations</li>\n    <li>Information Theft</li>\n    <li>Code Theft</li>\n    <li>Intellectual Property Theft</li>\n    <li>Reputational Damage</li>\n</ul>\n", "heading": "Do not use default Android cryptographic security provider encryption and follow the recommended practices"}, {"nonCompliant": "<ol>\n<li>\n\n<p>Facebook SDK for Android contained the following code which sends Facebook access tokens to log output in plain text format.</p>\n\n<pre>Log.d(<span style=' color: Maroon;'>\"Facebook-authorize\"</span>, <span style=' color: Maroon;'>\"Login Success! access_token=\"</span> +\n         getAccessToken() + <span style=' color: Maroon;'>\" expires=\"</span> + getAccessExpires());</pre>\n</li>\n\n<li>\n<p>Here is another example. A weather report for Android sent a user's location data to the log output as follows:</p>\n\n<pre>\nI/MyWeatherReport( 6483): Re-use MyWeatherReport data\nI/ ( 6483): GET JSON:\nhttp://example.com/smart/repo_piece.cgi?arc=0&lat=26.209026&lon=127.650803&rad=50&dir=-999&lim=52&category=1000\n</pre>\n\n<p>\nIf a user is using Android OS 4.0 or before, other applications with READ_LOGS permission can obtain the user's location\ninformation without declaring ACCESS_FINE_LOCATIONpermission in the manifest file.\n</p>\n</li>\n</ol>\n", "description": "Current Application was found to be writing logs to the system logs", "relatedTo": "<ul>\n    <li>\n        Facebook SDK for Android: <a href=\"http://readwrite.com/2012/04/10/what-developers-and-users-can#awesm=~o9iqZAMlUPshPu\">http://readwrite.com/2012/04/10/what-developers-and-users-can#awesm=~o9iqZAMlUPshPu</a>\n    </li>\n    <li><a href=\"https://jvn.jp/en/jp/JVN23328321/\">JVN#23328321</a> Puella Magi Madoka Magica iP for Android vulnerable to information disclosure</li>\n    <li><a href=\"https://jvn.jp/en/jp/JVN86040029/\">JVN#86040029</a> Weathernews Touch for Android stores location information in the system log file</li>\n    <li><a href=\"https://jvn.jp/en/jp/JVN33159152/\">JVN#33159152</a> Loctouch for Android information management vulnerability</li>\n    <li><a href=\"https://jvn.jp/en/jp/JVN56923652/\">JVN#56923652</a> Monaca Debugger for Android information management vulnerability</li>\n</ul>", "intro": "<p>\n    Android provides capabilities for an app to output logging information and obtain log output. Applications can send information to log output using the android.util.Log class. To obtain log output, applications can execute the logcat command.\n</p>", "id": 17, "name": "Application Logs", "uuid": "9ad5223b-2354-5f09-a6ec-f4f9672aa68b", "type": "vulnerabilities", "question": "Is this Application giving out data through its App Log?", "successMessage": "No Application logs were found", "compliant": "", "businessImplication": "", "heading": "Do not log sensitive information"}, {"nonCompliant": "", "description": "Logical Flaws through API which can bypass Authorization and get information about other Users and Reset Passwords. Authorization and Authenticated sessions were not properly validated on both Client or Server Side", "relatedTo": "<p>Automated tools find it hard to understand context, hence it's up to a person to perform these kinds of tests. The following two examples will illustrate how understanding the functionality of the application, the developer's intentions, and some creative \"out-of-the-box\" thinking can break the application's logic. The first example starts with a simplistic parameter manipulation, whereas the second is a real world example of a multi-step process leading to completely subvert the application.\n</p>\n<p><br>\n<b>Example 1</b>:\n</p>\n<p>Suppose an e-commerce site allows users to select items to purchase, view a summary page and then tender the sale. What if an attacker was able to go back to the summary page, maintaining their same valid session and inject a lower cost for an item and complete the transaction, and then check out?\n</p>\n<p><br>\n<b>Example 2</b>:\n</p>\n<p>Holding/locking resources and keeping others from purchases these items online may result in attackers purchasing items at a lower price. The countermeasure to this problem is to implement timeouts and mechanisms to ensure that only the correct price can be charged.\n</p>\n<p><br>\n<b>Example 3</b>:\n</p>\n<p>What if a user was able to start a transaction linked to their club/loyalty account and then after points have been added to their account cancel out of the transaction?  Will the points/credits still be applied to their account?\n</p>\n", "intro": "<p> Most security problems are weaknesses in an application that result from a broken or missing security control (authentication, access control, input validation, etc...). By contrast, business logic vulnerabilities are ways of using the legitimate processing flow of an application in a way that results in a negative consequence to the organization.\n</p>\n<p>Too often, the business logic category is used for vulnerabilities that can't be scanned for automatically. This makes it very difficult to apply any kind of categorization scheme. Business logic problems are different from authentication problems and every other category. There are many signficant business logic vulnerabilities, but they are far less common than the type of items.</p>\n", "id": 18, "name": "Business Logic", "uuid": "611f84b3-ab8e-5ff2-9db0-2f16c607f222", "type": "vulnerabilities", "question": "Was Logical Flaws found in the API?", "successMessage": "No logical flaws were found", "compliant": "<p>\nThe following should be checked and properly fixed\n</p>\n<ul>\n<li>Check for OTP in server side rather than in Client Side</li>\n<li>Use proper Authentication not same authorization token like <b>Authorization: Basic aW50ZXJhY3Rpb25vbmU6bW9iaTEyMw==</b> which translates to: <b>interactionone:mobi123</b></li>\n<li>never use passwords like mobi123</li>\n</ul>\n", "businessImplication": "", "heading": "Business Logic Vulnerability."}]